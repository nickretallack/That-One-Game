// Generated by CoffeeScript 1.3.3
(function() {
  var Board, Tile, V, Vector, random_choice, tile_count, tile_size, tile_types;

  Vector = (function() {

    function Vector(x, y) {
      this.x = x;
      this.y = y;
    }

    Vector.prototype.add = function(vector) {
      return V(vector.x + this.x, vector.y + this.y);
    };

    Vector.prototype.scale = function(factor) {
      return V(this.x * factor, this.y * factor);
    };

    Vector.prototype.css_position = function() {
      return {
        left: this.x,
        bottom: this.y
      };
    };

    Vector.prototype.css_size = function() {
      return {
        width: this.x,
        height: this.y
      };
    };

    return Vector;

  })();

  V = function(x, y) {
    return new Vector(x, y);
  };

  tile_size = 40;

  tile_count = V(10, 9);

  tile_types = "burger hotdog pizza".split(' ');

  random_choice = function(choices) {
    var index;
    index = Math.floor(Math.random() * choices.length) % choices.length;
    return choices[index];
  };

  Tile = (function() {

    function Tile(_arg) {
      this.position = _arg.position, this.board = _arg.board, this.type = _arg.type;
      _.bindAll(this);
      this.element = $("<div class=\"positioned tile " + this.type + "\"></div>");
      this.element.css({
        position: 'absolute'
      });
      this.element.css(V(tile_size, tile_size).css_size());
      this.re_position();
      this.element.on('click', this.clicked);
    }

    Tile.prototype.re_position = function() {
      return this.element.css(this.position.scale(tile_size).css_position());
    };

    Tile.prototype.position_key = function() {
      return "" + this.position.x + "-" + this.position.y;
    };

    Tile.prototype.clicked = function() {
      return this.board.find_contiguous(this);
    };

    return Tile;

  })();

  Board = (function() {

    function Board(_arg) {
      var tile, x, y, _i, _j, _ref, _ref1;
      this.element = _arg.element;
      this.element.css(tile_count.scale(tile_size).css_size());
      this.tiles = {};
      for (x = _i = 0, _ref = tile_count.x; 0 <= _ref ? _i < _ref : _i > _ref; x = 0 <= _ref ? ++_i : --_i) {
        for (y = _j = 0, _ref1 = tile_count.y; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; y = 0 <= _ref1 ? ++_j : --_j) {
          tile = new Tile({
            position: V(x, y),
            board: this,
            type: random_choice(tile_types)
          });
          this.register_tile(tile);
          this.element.append(tile.element);
        }
      }
    }

    Board.prototype.register_tile = function(tile) {
      return this.tiles[tile.position_key()] = tile;
    };

    Board.prototype.unregister_tile = function(tile) {
      return delete this.tiles[tile.position_key()];
    };

    Board.prototype.move_tile = function(tile, position) {
      unregister_tile(tile);
      tile.position = position;
      return register_tile(tile);
    };

    Board.prototype.find_contiguous = function(tile) {
      var contigious, work_queue, _results;
      contigious = {};
      work_queue = [tile];
      _results = [];
      while (work_queue.length) {
        _results.push(tile = work_queue.pop());
      }
      return _results;
    };

    return Board;

  })();

  $(function() {
    return new Board({
      element: $('#game')
    });
  });

}).call(this);
